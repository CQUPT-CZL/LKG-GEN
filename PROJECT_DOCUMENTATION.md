# LKG-GEN 项目文档

本文档全面介绍了 LKG-GEN (Large Knowledge Graph Generator) 知识图谱生成平台，包括项目简介、技术架构、安装部署、核心功能操作手册。

---

## 1. 项目简介 (Project Overview)

LKG-GEN 是一个基于大知识库的智能知识图谱生成与管理平台。它能够将非结构化的文本数据（如论文、报告等）转化为结构化的知识图谱，并提供可视化的图谱展示、实体关系管理以及基于图谱的智能问答功能。

**核心价值：**
- **自动化图谱构建**：利用大语言模型（LLM）自动从文本中提取实体和关系。
- **可视化交互**：直观展示知识节点及其关联，支持交互式探索。
- **智能问答**：结合 RAG（检索增强生成）与知识图谱，提供精准的问答服务。
- **全流程管理**：支持从文档上传、图谱构建到实体修正的全流程管理。

---

## 2. 技术架构 (Technical Architecture)

本项目采用前后端分离架构，确保系统的高扩展性与维护性。

### 2.1 技术栈

| 模块 | 技术选型 | 说明 |
| :--- | :--- | :--- |
| **前端 (Frontend)** | React 18 | 用户界面构建 |
| | TypeScript | 静态类型检查 |
| | Ant Design | UI 组件库 |
| | Vis.js (vis-network) | 知识图谱可视化渲染 |
| | Axios | HTTP 请求处理 |
| **后端 (Backend)** | Python 3.13+ | 核心开发语言 |
| | FastAPI | 高性能 Web 框架 |
| | Pydantic | 数据验证与设置管理 |
| | LangChain / LLM | 大模型集成与 Prompt 管理 |
| **数据库 (Database)** | Neo4j | 图数据库，存储实体与关系 |
| | SQLite | 关系型数据库，存储文档原文与系统配置 |

### 2.2 核心流程逻辑

1. **文档处理**：用户上传文档 -> 后端存储至 SQLite -> 触发知识抽取任务。
2. **知识抽取**：文档分块 -> LLM 提取实体与关系 -> 数据清洗 -> 存入 Neo4j。
3. **图谱应用**：前端通过 API 获取图数据 -> Vis.js 渲染 / 聊天界面调用 RAG 接口。

---

## 3. 环境准备 (Environment Setup)

在部署项目前，请确保本地环境满足以下要求：

- **操作系统**：Linux (推荐), MacOS, Windows
- **Python**：版本 >= 3.13
- **Node.js**：版本 >= 16.0 (推荐使用 LTS 版本)
- **Neo4j**：版本 >= 5.15 (需开启 Bolt 端口，默认 7687)

---

## 4. 安装与启动 (Installation & Setup)

### 4.1 启动后端服务

本项目推荐使用 `uv` 进行环境管理，虚拟环境位于项目根目录下。

1.  **安装 uv** (如果尚未安装)：
    ```bash
    pip install uv
    # 或者参考 uv 官方文档
    ```

2.  **初始化环境与安装依赖**：
    在项目根目录 (`LKG-GEN/`) 下执行：
    ```bash
    uv sync
    ```
    *这将根据 `pyproject.toml` 和 `uv.lock` 自动创建 `.venv` 虚拟环境并安装所有依赖。*

3.  **激活虚拟环境**：
    ```bash
    source .venv/bin/activate
    # Windows: .venv\Scripts\activate
    ```

4.  **启动后端服务**：
    ```bash
    cd backend
    python main.py
    ```
    *后端服务默认运行在 `http://localhost:8000`*

### 4.2 启动前端服务

1.  进入前端目录：
    ```bash
    cd frontend
    ```

2.  安装依赖：
    ```bash
    npm install
    # 或者
    pnpm install
    ```

3.  启动开发服务器：
    ```bash
    npm start
    ```
    *前端页面默认运行在 `http://localhost:3000`*

---

## 5. 操作手册 (Operation Manual)

本章节详细说明系统的各个功能模块及操作步骤。

### 5.1 系统仪表盘 (Dashboard)
登录系统后，首先进入仪表盘页面。此处展示了系统的整体统计数据，包括知识图谱总数、文档总数等核心指标。

![仪表盘页面截图](screenshots/dashboard.png)
*(请将您的截图命名为 `dashboard.png` 并保存在项目根目录的 `screenshots` 文件夹中)*

### 5.2 知识图谱构建 (Knowledge Graph Builder)
在此模块中，您可以创建和配置新的知识图谱项目。

**功能说明：**
- **步骤引导**：系统采用分步向导模式，包括文档清洗、分块、实体提取、消歧、关系提取等阶段。
- **状态监控**：实时显示各阶段的处理状态（如：文档清洗中、实体提取中）。
- **文件上传**：支持拖拽上传 Markdown 文件。
- **图谱选择**：可选择将新文档添加到现有图谱或创建新图谱。

![知识图谱构建页面截图](screenshots/graph_builder.png)


### 5.3 知识图谱管理 (Knowledge Graph Management)
本模块包含图谱的详细管理功能，分为以下子模块：

#### 5.3.1 图谱概览 (Graph Overview)
查看当前系统中所有图谱的列表。

**功能说明：**
- **列表展示**：显示图谱名称、描述、创建时间等信息。
- **快捷操作**：支持查看详情、编辑基本信息或删除图谱。

![图谱概览页面截图](screenshots/graph_overview.png)

#### 5.3.2 文档管理 (Document Manager)
在此模块中，您可以查看和管理SQLite数据库中的源文档及其处理状态。

**功能说明：**
- **状态概览**：顶部卡片展示文档总数、待处理、处理中及已完成的文档数量。
- **列表管理**：查看文档ID、文件名、资源类型、当前状态及上传时间。
- **文档操作**：
    - **查看**：预览文档内容。
    - **删除**：移除文档及相关记录。
    - **刷新列表**：获取最新的文档处理进度。

![文档管理页面截图](screenshots/document_manager.png)

#### 5.3.3 实体管理 (Entity Manager)
图谱构建完成后，您可以在此查看和修正提取出的实体。

**功能说明：**
- **筛选查询**：支持按所属图谱、源文档进行筛选，或搜索实体名称。
- **列表展示**：查看实体名称、类型、描述等详细信息。
- **子图预览**：支持查看选中实体的关联子图。
- **管理操作**：编辑实体属性或删除错误实体。

![实体管理页面截图](screenshots/entity_manager.png)



#### 5.3.4 关系管理 (Relation Manager)
在此管理实体之间的关联关系。

**功能说明：**
- **筛选查询**：支持按所属图谱、源文档进行筛选。
- **三元组列表**：直观展示“源实体 -> 关系 -> 目标实体”结构。
- **关系维护**：支持手动创建新关系，编辑现有关系类型，或断开错误连接。

![关系管理页面截图](screenshots/relation_manager.png)


#### 5.3.5 分类管理 (Category Manager)
用于管理知识图谱的分类体系结构。

**功能说明：**
- **树状视图**：以树形结构展示分类层级。
- **分类维护**：选择图谱后，可添加新的分类节点，构建层次化的知识体系。
- **子图关联**：查看特定分类下的知识子图。

![分类管理页面截图](screenshots/category_manager.png)


### 5.4 实体歧义消除 (Entity Disambiguation)
处理同名异义或异名同义的实体问题。

**功能说明：**
- **自动检测**：基于 Embedding 相似度自动检测潜在的重复实体对。
- **建议列表**：展示检测到的相似实体对及其相似度分数。
- **合并操作**：提供界面让用户确认并合并实体，统一知识表达。

![实体歧义消除页面截图](screenshots/entity_disambiguation.png)


### 5.5 图谱可视化 (Graph Visualization)
这是系统的核心展示界面。

**功能亮点：**
- **交互式画布**：支持拖拽节点、缩放视图，探索图谱结构。
- **工具栏**：提供全屏、下载截图、搜索定位、布局刷新等实用工具。
- **详情侧栏**：点击节点或连线，侧边栏显示详细属性及原始文本来源。
- **设置面板**：自定义节点大小、颜色及布局算法。

![图谱可视化页面截图](screenshots/graph_visualization.png)


### 5.6 图谱问答 (Graph QA)
基于构建好的知识图谱进行自然语言问答。

**操作步骤：**
1. **选择图谱**：在下拉框中选择要进行问答的知识图谱。
2. **提问互动**：在对话框输入问题，系统将结合图谱数据生成答案。
3. **结果展示**：答案中包含引用的知识路径，并提供相关的图谱可视化切片。

![智能问答页面截图](screenshots/chat_qa.png)


### 5.7 系统设置 (Settings)
在此配置系统的核心参数。

**功能模块：**
- **常规设置**：配置系统名称、语言、主题及自动保存策略。
- **处理配置**：调整文件处理的批次大小、并发数等性能参数。
- **AI 配置**：设置 LLM 模型、API Key、Temperature 等参数。
- **可视化配置**：自定义图谱的默认展示样式。

![系统设置页面截图](screenshots/settings.png)

---

## 6. 目录结构说明 (Directory Structure)

### 后端结构 (`backend/`)
- `app/api/`：API 路由定义。
- `app/core/`：核心业务逻辑（抽取器、清洗器等）。
- `app/db/`：数据库连接会话（Neo4j, SQLite）。
- `app/models/` & `app/schemas/`：数据模型定义。
- `app/services/`：业务服务层（文档处理、图谱服务）。
- `app/worker/`：**后台任务队列（文档提取图谱核心部分）**。

### 前端结构 (`frontend/src/`)
- `components/`：通用 UI 组件。
- `pages/`：各功能页面组件（Dashboard, Chat, Graph 等）。
- `services/`：API 接口封装。

---

## 7. 常见问题 (FAQ)

**Q: 支持哪些文档格式？**
A: 目前主要支持 Markdown (.md) 格式的文档。对于其他格式（如 PDF, TXT），建议先转换为 Markdown 格式后再上传。

**Q: 如何设计prompt模板？**
A：
有三个主要的prompt模板：
1. 实体抽取模板：用于从文档中提取实体。
2. 关系抽取模板：用于从文档中提取实体之间的关系。
3. 总结文章模版：将上传的md文件整理为一段摘要。

**请详细阅读模版，里面有一些变量的占位符，如需自己设计，这些占位符必须保留。**

1.实体抽取模板：
```
你是一位顶级的知识图谱实体抽取（NER）专家，专门从【钢铁行业设备故障】相关的文本中，提取出原子化、精简且结构化的实体信息。

你的最终目标是为故障归因分析（Root Cause Analysis）知识图谱提供高质量的数据节点，因此，实体的核心概念必须被精准提炼出来。

【核心原则：实体原子化与精简】
你必须将识别出的问题、原因或方案，提炼成其最核心、最简洁的名词或动名词短语。去除所有冗余的修饰词（如“持续的”、“轻微的”、“一个”）、口语化表达、过程性描述以及任何具体的数值（如偏差值、温度、时间、尺寸等）。

例如:

“炉温近期持续异常” → “炉温异常”

“冷却壁出现了轻微泄漏” → “冷却壁泄漏”

“我们需要一套专用的液压工具” → “专用液压工具”

“F4零调辊缝偏差0.373mm” → “F4零调辊缝偏差” （去除数值）

“加热炉温度达到1200℃” → “加热炉温度过高” 或 “加热炉温度异常” （去除具体数值，概括问题）

你的任务是从下面提供的【文本块】中，识别并提取出所有符合【预定义实体类型】的实体。

【文本块】:
{text}

【预定义实体类型】:
请只使用以下预定义实体类型进行标注。
{entity_types}

【思维链：严格遵循以下步骤】

理解上下文：通读文本，理解故障的核心场景与逻辑。

识别并精炼实体：

问题：识别设备异常或故障现象，并精简为核心短语。

原因：识别导致问题发生的根本原因。如果原文包含具体数据（如“-2000N”），请在后续描述中保留。

解决方案：识别为解决问题提出的行动或计划。

组件：识别故障中提及的设备、部件或工具。如果问题主体是某个组件，需同时提取“问题”实体和“组件”实体。

精准分类与描述：

将每个精炼后的实体归类到**【预定义实体类型】**。

为每个实体生成一个精简描述，点明其本质，不超过30字。

【特别注意】：对于原因实体，如果文本提供了数据依据，请将该数据融入描述中。例如：“因为废钢前F1活套压差长期保持在-2000N左右”。

格式化输出：将所有实体严格按照以下JSON格式进行组织，不包含任何多余解释。

【示例】
假设文本块是：
"2号高炉的炉温近期持续异常，经过排查，原因是冷却壁出现了轻微泄漏。为了解决这个问题，我们计划更换新的冷却壁，这需要一套专用的液压工具。"

你应该抽取出以下实体：
[
  {{
    "entity_text": "炉温持续异常",
    "entity_type": "问题",
    "entity_description": "描述了设备发生的主要问题或异常现象。"
  }},
  {{
    "entity_text": "冷却壁出现轻微泄漏",
    "entity_type": "原因",
    "entity_description": "导致炉温异常的根本原因。"
  }},
  {{
    "entity_text": "更换新的冷却壁",
    "entity_type": "解决方案",
    "entity_description": "针对冷却壁泄漏问题提出的解决方法。"
  }},
{{
    "entity_text": "废钢前F1活套压差异常",
    "entity_type": "原因",
    "entity_description": "因为废钢前F1活套压差长期保持在-2000N左右，导致板型偏向操作侧。"
  }},
  {{
    "entity_text": "2号高炉",
    "entity_type": "组件",
    "entity_description": "问题发生的具体设备或部件。"
  }},
  {{
    "entity_text": "冷却壁",
    "entity_type": "组件",
    "entity_description": "问题涉及的具体设备部件。"
  }},
  {{
    "entity_text": "专用的液压工具",
    "entity_type": "组件",
    "entity_description": "执行解决方案所需要的工具或备件。"
  }}
]


请严格遵循以下规则：
1.  抽取的实体必须是包含以下字段的JSON对象格式：
    - "entity_text": 从原文中抽取的实体文本。
    - "entity_type": 实体所属的预定义类型。
    - "entity_description": 对该实体的简要描述。
2.  `entity_type` 必须是【预定义实体类型】中列出的一个。
请严格按照以下JSON格式返回结果，不要有任何多余的解释。
如果文本中没有找到任何实体，请返回一个空的列表 `[]`。
```


2. 关系抽取模板：
```
你是一位顶级的知识图谱关系抽取（RE）专家，专门从【钢铁行业设备故障】相关的文本中，提取出实体之间的因果关系和功能关系。

你的最终目标是输出一组结构化的三元组（head, relation, tail），用于构建一个逻辑连贯、可用于归因分析的知识图谱。

【文本块】:
{text}

【实体列表】:
这是从文本块中提取出的实体，请只在这些实体之间寻找关系。
{entities}

【预定义关系类型】:
请只使用以下预定义的关系类型。
{relation_types}

【任务：思维链 (Chain of Thought)】
请严格遵循以下思维步骤来完成任务：

全局理解: 通读【文本块】和【实体列表】，理解整个故障事件的来龙去脉。

定位核心问题: 从实体列表中，首先找出代表**最终“问题”或“故障”**的核心实体。这将是你构建关系网的起点。

反向追溯因果链: 从核心“问题”出发，在文本中反向追溯，寻找直接或间接“导致”它的“原因”或“现象”。然后继续对找到的“原因”追溯其上一级“原因”，直到构建出一条完整的因果链。

识别解决方案: 在文本中寻找是否有实体被描述为用于“解决”某个“问题”。

识别功能需求: 检查是否有“解决方案”实体在功能上“需要”某个“组件”实体。

构建三元组: 根据上面识别出的所有关联，构建(头实体, 关系, 尾实体)的三元组列表。

【关键】精确验证: 最后一步，也是最重要的一步，检查你构建的每一个三元组：

确保head和tail中的实体名称，与【实体列表】中提供的名称一字不差，完全相同。严禁任何形式的改写、缩写或概括。

确保relation必须是【预定义关系类型】中的一个。

确保关系方向严格遵循下面的【关系方向规则】。

【示例】
假设文本块是：
"2号高炉的炉温近期持续异常，经过排查，原因是冷却壁出现了轻微泄漏。为了解决这个问题，我们计划更换新的冷却壁，这需要一套专用的液压工具。"

实体列表包含：
- "炉温持续异常" (问题)
- "冷却壁出现轻微泄漏" (原因)
- "更换新的冷却壁" (解决方案)
- "2号高炉" (组件)
- "冷却壁" (组件)
- "专用的液压工具" (组件)

你应该抽取出以下关系：
```json
[
  {{
    "head": "冷却壁出现轻微泄漏",
    "relation": "导致",
    "tail": "炉温持续异常",
    "description": "冷却壁的泄漏问题直接导致了炉温异常。"
  }},
  {{
    "head": "更换新的冷却壁",
    "relation": "解决",
    "tail": "炉温持续异常",
    "description": "通过更换冷却壁来解决炉温异常问题。"
  }},
  {{
    "head": "更换新的冷却壁",
    "relation": "需要",
    "tail": "专用的液压工具",
    "description": "执行冷却壁更换工作需要使用专用的液压工具。"
  }}
]
```

请严格遵循以下规则：
1.  抽取的关系必须是包含以下字段的JSON对象格式：
    - "head": 头实体（必须从实体列表中一字不差地选择）
    - "relation": 关系类型（必须是预定义关系类型之一）
    - "tail": 尾实体（必须从实体列表中一字不差地选择）
    - "description": 对该关系的简要描述
2.  如果文本中没有可抽取的关系，请返回一个空列表 `[]`。
3.  **直接返回纯JSON**：不要添加任何解释、注释或Markdown代码块标记（如```json...```），直接返回JSON列表。
```


3.文档净化模板：
```
你是一个专业的文档净化工具，负责从原始文档中提取出有用的信息，去除无用的markdown语法、表格、图片等。

Args:
    content: 原始文档内容

Returns:
    净化后的文档内容
```

## 8. 待修复的BUG
1. 上传文档进行解析时有较低的概率失败（因为有时候模型可能并不是输出的JSON格式，导致解析失败），但目前前端暂时没有处理这种情况的机制，会导致解析失败时前端依然显示成功。

2. 在配置中进行实体类型和关系的类型的重定义时，保存后可能还是之前的类型，需要重启后端才可以生效（这是因为这些类型不是存在数据库中的，不是每次请求都从数据库中读取的，是后端启动一次性读取的）



